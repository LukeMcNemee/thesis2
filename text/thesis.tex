%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital, %% This option enables the default options for the
           %% digital version of a document. Replace with `printed`
           %% to enable the default options for the printed version
           %% of a document.
  table,   %% Causes the coloring of tables. Replace with `notable`
           %% to restore plain tables.
  nolof,     %% Prints the List of Figures. Replace with `nolof` to
           %% hide the List of Figures.
  nolot,     %% Prints the List of Tables. Replace with `nolot` to
           %% hide the List of Tables.
           %draft, %TODO remove, place final instead
           oneside
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
%\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  %german, russian, czech, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
\def\textrussian#1{{\usefont{T2A}{PTSerif-TLF}{m}{rm}#1}}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = mgr,
    author        = Lukáš Němec,
    gender        = m,
    advisor       = {RNDr. Petr Švenda, Ph.D.},
    title         = {Edu-hoc: Experimental and educational platform for wireless ad-hoc networking},
    TeXtitle      = {Edu-hoc: Experimental and educational platform for wireless ad-hoc networking},
    keywords      = {keyword1, keyword2, ...},
    TeXkeywords   = {keyword1, keyword2, \ldots},
}
\thesislong{abstract}{
    TODO abstract
}
\thesislong{thanks}{
    TODO thanks

}
%% The following section sets up the bibliography.
\usepackage{csquotes}
\usepackage[              %% When typesetting the bibliography, the
  backend=biber,          %% `numeric` style will be used for the
  style=numeric,          %% entries and the `numeric-comp` style
  citestyle=numeric-comp, %% for the references to the entries. The
  sorting=none,           %% entries will be sorted in cite order.
  sortlocale=auto         %% For more unformation about the available
]{biblatex}               %% `style`s and `citestyles`, see:
%% <http://mirrors.ctan.org/macros/latex/contrib/biblatex/doc/biblatex.pdf>.
\addbibresource{bibliography.bib} %% The bibliograpic database within
                          %% the file `example.bib` will be used.
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}
\usepackage{menukeys}
\begin{document}


%% We will define several mathematical sectioning commands.
%\newtheorem{theorem}{Theorem}[section] %% The numbering of theorems
                               %% will be reset after each section.
%\newtheorem{lemma}[theorem]{Lemma}     %% The numbering of lemmas
%\newtheorem{corr}[theorem]{Corrolary}  %% and corrolaries will
                                %% share the counter with theorems.
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\theoremstyle{remark}
%\newtheorem*{remark}{Remark}

\chapter{Introduction}
\chapter{ Problem analysis (testbed, not general WSN)}
  \section{Creating WSN network}
  \section{Possible challenges}
\chapter{TESTBED deployment}
  \section{Network design}
  \section{JeeTool (mass managment and communication)}
  \section{HW (Arduino, JeeNodes, RF12B radio ...)}\label{sec:hw}
\chapter{Research use}
  \section{Keys from radio signal}
    \subsection{Quantization principle (bits from signal strength)}
    Quantization enables to extract bits from individual values of signal strength. There are many different approaches to this problem %\CITE
    two main approaches here are: lossless quantization %CITE
    and contrary to that we have lossy quantization.

    Main difference between these is number of generated bits per original signal strength measurements, while lossless quantization produces bit value from every measurement of signal strength, which is usefull for high performance demands, but it requires guaranteed varinace in the radio channel (e.g. the nodes are constantly moving, or the nevironment is changing) during the key establishment phase. %CITE
    Otherwise the resulting keys could possibly be wery weak. %CITE

    Lossy quantization on the other hand does not have guaranteed output lenght per number of measured values, which can lead to very limited length of output. However this kind of quantization is expected to have better results in static enviroments %CITE if possible
    because its nature is to drop such bits, that fail to differ from others.

    Since our network is static and without any moving nodes, we implemented lossy quantizer algorithm designed by Mathur et.al.%/TODO verify name
    , which shoved promissing results for the of the shelf wireless devices simmilar to ours, and also contained experimental results from several different scenarios, where some of these were comparable to our conditions.

    \subsection{RSSI version}
    Quantization princeple designed by Mathur et.al. %CITE
     works as follows:

    \begin{enumerate}
      \item both nodes send $n$ messages to each other in alternating pattern, both nodes send counter value inside these messages, which is used to synchronize messages on individual nodes. For every one of these messages signal strength is measured upon repection.
      \item when $n$ messages have been succesfully exchanged, both nodes can proceed to the computational part.
      \item both nodes calculate mean $m$ and standart deviation $sd$ for signal strength values of all received messages.
      \item both nodes calculate $q^+$ and $q^-$ values, which are upper and lower quantizer bin boundaries, as follows:
      $$q^+ = m + \alpha \cdot sd$$
      $$q^- = m - \alpha \cdot sd$$
      \item every signal strength measurement is then processed and it is rejected, if it lies within $q^+$ and $q^-$ boundaries, values above this range are assigned with bit value of one, values below are assigned with bit value of 0.
      \item nodes then synchronize their measurement by exchanging counter values asciated with those messages, where signal strength measurements were asigned either one or zero bit values.
      \item those counter values that match on both nodes are expected to be excursions in the same direction and are used in the final outcome.

      %TODO add some nice picture that would show this
    \end{enumerate}
    \subsection{CSI (channel state) version}
  \section{Cooperative jamming (can it improve our situation?)}
  \section{Performance Evaluation (results from experiments)}
    \subsection{Enthropy of data}
    \subsection{Speed (bits of key per time)}
    \subsection{Possible errors}
  \section{Discussion, is it achievable and under what conditions?}
\chapter{Education use}

  \section{motivation for educational WSN network}
  The current state of the art WSN devices usually uses specialized hardware
  and software in order to achieve the best performance available. %\CITE
  This, unfortunately, is not the ideal prerequisite for an easy to learn matter. In fact, most of WSN devices have rather complicated setup and are
  quite challenging for novices. %\CITE

  Because of such discouragement, it is difficult to teach how to
  work with WSN’s; few hours (at least) are usually required
  to explain the basics, which is reasonable for research project or
  something similar, but for class exercise, this would turn out to be
  not the most effective use of time, if it would be achievable at all. And
  we have not yet mentioned more advanced topics in this area, such as
  common techniques for encryption or message authentication.

  Issue of this nature can be solved in various ways,
  in case of Edu-hoc we decided to sacrifice performance \ref{sec:hw}; which is not that much important for network with educational purpose. On the other hand, using hardware that is really easy to comprehend and use is of a great benefit here. Also having less powerfull, but realtively cheap devices (in range of \$30 rather than \$100 or more) gives the opportunity to lend each the students one of the devices, so that they can try the basics on their own, and also use this device for interactions with the network.

  \section{Scenario approach (attack and repair) + iterative higher difficulty}
  In order to make learning more enjoyable experience and also to add some challenging part to the learning process, we decided to make Edu-hoc scenario based; each scenario being composed of two distinct parts: first part in the role of an attacker (both enjoyable and educational) and the second part as a code reviewer or developer (primarily educational).

  \paragraph{attacker part of a scenario}\label{par:att}
    Students are presented with network application which has known, or easily detectable, vulnerability. Task is to take advantage of such vulnerability and exploit it using own nodes and carefully executed interactions with the network. How successful these effords were can be easily evaluated by percentage differece from the expected traffic of the network or by presenting learned secret in the submission of the solution. Exact methods of evaluation are described in \ref{sec:eval}.

  \paragraph{reviewer part of a scenario}
    Important part of the educational process is not only to find mistakes, but also to be able to correct them. The task in this part of scenario is then to take current source code of application, hich has been deployed on the network during the attacker part \ref{par:att}, correctly identify which mistakes were made and propose changes in the code, which would make the application secure against such kind of an attack. Exact evaluation methods are again described in \ref{sec:eval}.


    \subsection{1st scenario - Eavesdropping}
    First scenario can be considered really simple and it is by design. Since this scenario is the first encouner with Edu-hoc, we opted for passive attacker approach, without any actual interaction with the network, just listening for any traffic.

    Eavesdropping is also the first thing one would do, if one would be about to attack some network, because it does not compromise the presence of an attacker and intercepted messages may provide many usefull informations. This is another important reason why this task was selected as a first one, not only it is rather easy to do, but it provides vital information for the rest of the excercises (e.g. which nodes are present in the network, which frequency is used and what are the settings of the radio)

    \paragraph{scenario setting}
    Each node in the network sends messages, after each message there is a delay of 1000 ms, therefore any receiving node has time to process the transmitted messages. All messages are send as a broadcast and nodes within the network do not receive nor process them, since it is not needed for succesfull scenario run. If this would be the case, transmission rates would have been updated acordingly and scenario would be much more likely to fail on its own, because of single node malfunction, while with current settings, network can operate without any problems even is several of the nodes would fail.

    \paragraph{attack principle}
    Attack is very simple, attacker node only has to listen for any traffic present in the network. For best results application has to be able to process as many messages as possible, however any performance changes will affect the end result only slightly (final percentage will be better, but the bottle neck is in the processor of the radio module, so better optimalised application will increase the end result only by approximately 10-20\%)
    \paragraph{application and securing it}
    Main issue with the application is unencrypted broadcast. This can be fixed quite easily, just by addition of simple encryption and for simplicity using common shared key. We have to be avare of the fact, that attacker might be able to collect some of the nodes and thus learn such key and compromise it and there are techniques which deal with this problem %CITE
    However, in our scenario this is sufficient solution, because it is adequate measure against eavesdropping.

    \subsection{2nd scenario - Black hole attack}
    This scenario presents more advanced concepts, dynamic routing in particular. The task is to attack the routing alghoritm and diverse all trafic, so that the central node does not receive any messages. This scenario requires active attacker, thus some basic interaction with the network.

    \paragraph{scenario setting}
    Scenario is divided into two parts, first parts is shorter and is used to establish routes for this particular run of scenario. Without any attack or interference outside from the network these routes should be always the same.

    In the following part of scenario each node periodically sends messages to the parent node, therefore all messages are routed to the central node. This node then counts all received messages and final outcome is the number of expected messages compared to the number of actual messages received.

    \paragraph{attack principle}
    This attack requires some prior knowledge before execution which can be obtained simply by using eavesdropping technique from previous excercise. This way an attacker can learn how the routing alghoritm works (nodes broadcast their current distance to the central node, where central node has distance of 0, all nodes that hear distance anouncement message then update their distance and broadcast this updated distance)

    With this knowledge attacker than try to inject message with the same content as the central node does, but earlier than the central node is scheduled to do so. After this the message from central node will not improve position of other nodes and they will not update their distance. Other possible approach is to find intentional weakness in the alghoritm implementation (application allowes negative distance values).

    Only thing that remains is to make sure to use nonexisting ID within the network and after the routing tree is established, attacker node can simply disapear, because it is no longer needed.

    \paragraph{application and securing it}
    In order to fix the application one has to fix two issues; check for negative counter values (which is the easy part and requires usually addition of one condition witin the code); and what is more important, implement some kind of authentication mechanism for messages from the central node, or othervise make sure that the attacker cannot diverse all the traffic only by being a bit faster than the central node.

    Many options are available, the most easy one being preshared random authentication tag, which would be added to the messages. This is really simple countermeasure, but it guarantees that the attacker canot send valid message before the central node sends it. 

  \section{Evaluation principle}\label{sec:eval}
  \section{Web interface and auto run}
  \section{PA197 use and results}
\chapter{Summary}




%%bibliography
%%==============================================================
{\csname captions\languagename\endcsname %% Temporarily override
%% the BibLaTeX localization with the original babel definitions.
\makeatletter %% Use the correct localization of the quotations.
  \thesis@selectLocale{\thesis@locale}\makeatother
\printbibliography[heading=bibintoc]} %% Print the bibliography.
%%==============================================================

\appendix %% Start the appendices.
\chapter{An appendix}

\end{document}
